# ---------------------------------------------------------------------------------------
#   @parent     : github workflow
#   @desc       : check plugin
#   @author     : Aetherinox
#   @url        : https://github.com/Aetherinox
# ---------------------------------------------------------------------------------------

name: "Plugin Check"
run-name: "Plugin Check"

on:
  pull_request:
    branches:
      - main

# ---------------------------------------------------------------------------------------
#   environment variables
#
#   >   PLUGIN_ID
#           0   = official repo
#           1   = development repo
# ---------------------------------------------------------------------------------------

env:
    PLUGIN_ID: 1

# ---------------------------------------------------------------------------------------
#   jobs
# ---------------------------------------------------------------------------------------

jobs:
  plugin-validation:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: "refs/pull/${{ github.event.number }}/merge"
      - name: Use Node.js
        uses: actions/setup-node@v2

      - name: Get changed files
        id: changed-files
        uses: tj-actions/changed-files@v42

      - name: List all added files
        run: |
          for file in ${MODIFIED_FILES}; do
            echo "$file was added"
          done
        env:
          ADDED_FILES: ${{ steps.changed-files.outputs.added_files }}
          MODIFIED_FILES: ${{ steps.changed-files.outputs.modified_files }}

      - name: Run Check
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');

            const escapeHtml = (unsafe) => unsafe.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#039;');
            const errors = [];
            const addError = (error) =>
            {
                errors.push(`:x: ${error}`);
                console.log('Found issue: ' + error);
            };

            const warnings = [];
            const addWarning = ( warning ) =>
            {
                warnings.push(`:warning: ${warning}`);
                console.log( 'Found issue: ' + warning );
            }

            const filesModified       = '${{ steps.changed-files.outputs.modified_files }}';
            const filesData           = fs.readFileSync( filesModified, 'utf8' );
            const bContainsStyle      = /([A-Za-z]+\.style\.[A-Za-z]+)/g.test( filesData.toLowerCase( ) );
            const bContainsGeneric    = /(?:^|(?<= ))(MyPlugin|MyPluginSettings|SampleSettings|SampleSettingTab|SampleModal)(?:(?= )|$)/gim.test( filesData.toLowerCase( ) );

            let error_Generic = "- `MyPlugin`" + 
             "- `MyPluginSettings`" + 
             "- `SampleSettings`" +
             "- `SampleSettingTab`" +
             "- `SampleModal`"

            const check_innerHtml   = "innerHTML"
            const check_outerHtml   = "outerHTML"
            const check_asAny       = "as any"

            await ( async ( ) =>
            {

                /*
                    Using inner / outter HTML
                */

                if ( filesData.toLowerCase( ).includes( check_innerHtml.toLowerCase( ) ) || filesData.toLowerCase( ).includes( check_outerHtml.toLowerCase( ) ) )
                {
                    addError( `Using \`innerHTML\` and \`outerHTML\` is a security risk. Instead, use the DOM API or the Obsidian helper functions: https://docs.obsidian.md/Plugins/User+interface/HTML+elements` );
                }

                /*
                    Casting to Any
                */

                if ( filesData.toLowerCase( ).includes( check_asAny.toLowerCase( ) ) )
                {
                    addError( "You should not be casting to `any`" );
                }

                /*
                    Using inline style
                */

                if ( bContainsStyle == true )
                {
                    addError( "You should avoid assigning `inline styles` via JavaScript or in HTML. Move all of these styles into CSS so that they are more easily adaptable by themes and snippets." );
                }

                /*
                    Generic Calls
                */

                if ( bContainsGeneric == true )
                {
                    addError( "Rename sample classes to something that makes sense. You are not allowed to have names such as: " + error_Generic );
                }

            })();

            if ( errors.length > 0 || warnings.length > 0 )
            {

                /*
                    Greeting
                */

                let message = [`#### Hello!\n`]
                message.push( `**I found the following issues in your pull request:**\n` );

                /*
                    Errors
                */

                if ( errors.length > 0 )
                {
                    message.push( `**Errors:**\n` );
                    message = message.concat( errors );
                    message.push( `\n---\n` );
                }

                /*
                    Warnings
                */

                if ( warnings.length > 0 )
                {
                    message.push( `**Warnings:**\n` );
                    message = message.concat( warnings );
                    message.push( `\n---\n` );
                }

                message.push( `<sup>This check was done automatically. Do <b>NOT</b> open a new PR for re-validation. Instead, to trigger this check again, make a change to your PR and wait a few minutes, or close and re-open it.</sup>` );

                await github.rest.issues.createComment(
                {
                    issue_number:   context.issue.number,
                    owner:          context.repo.owner,
                    repo:           context.repo.repo,
                    body:           message.join('\n'),
                });
            }
    
            const labels = [];

            if ( errors.length > 0 )
            {
                labels.push( "Validation failed" );
                core.setFailed( "Failed to validate pull request" );
            }

            if ( errors.length === 0 )
            {
                await github.rest.pulls.update(
                {
                    owner:        context.repo.owner,
                    repo:         context.repo.repo,
                    pull_number:  context.issue.number,
                    title:        `Review: ${context.payload.pull_request.title}`
                });

                if( !context.payload.pull_request.labels.filter( label => label.name === 'Changes requested' ).length > 0 )
                {
                    labels.push("Ready for review");
                }
            }

            if ( context.payload.pull_request.labels.filter( label => label.name === 'Changes requested' ).length > 0 )
            {
                labels.push('Changes requested');
            }

            if ( context.payload.pull_request.labels.filter( label => label.name === 'Additional review required' ).length > 0 )
            {
                labels.push( 'Additional review required' );
            }

            if (context.payload.pull_request.labels.filter(label => label.name === 'Minor changes requested').length > 0)
            {
                labels.push( 'Minor changes requested' );
            }

            if (context.payload.pull_request.labels.filter(label => label.name === 'requires author rebase').length > 0)
            {
                labels.push( 'requires author rebase' );
            }

            if (context.payload.pull_request.labels.filter(label => label.name === 'Installation not recommended').length > 0)
            {
                labels.push( 'Installation not recommended' );
            }

            if (context.payload.pull_request.labels.filter( label => label.name === 'Changes made' ).length > 0 )
            {
                labels.push( 'Changes made' );
            }
            
            if ( context.payload.pull_request.labels.filter( label => label.name === 'Skipped code scan' ).length > 0 )
            {
                labels.push( 'Skipped code scan' );
            }

            labels.push( 'Pull Request' );

            await github.rest.issues.setLabels(
            {
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                labels,
            });
    permissions:
      contents: read
      issues: write
      pull-requests: write