# ---------------------------------------------------------------------------------------
#   @parent     : github workflow
#   @desc       : check plugin
#   @author     : Aetherinox
#   @url        : https://github.com/Aetherinox
# ---------------------------------------------------------------------------------------

name: "Plugin Check"
run-name: "Plugin Check"

on:
  pull_request:
    branches:
      - main

# ---------------------------------------------------------------------------------------
#   environment variables
#
#   >   PLUGIN_ID
#           0   = official repo
#           1   = development repo
# ---------------------------------------------------------------------------------------

env:
    PLUGIN_ID: 1

# ---------------------------------------------------------------------------------------
#   jobs
# ---------------------------------------------------------------------------------------

jobs:
  plugin-validation:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: "refs/pull/${{ github.event.number }}/merge"
      - name: Use Node.js
        uses: actions/setup-node@v2

      - name: Get changed files
        id: changed-files
        uses: tj-actions/changed-files@v42

      - name: List all added files
        run: |
          for file in ${MODIFIED_FILES}; do
            echo "$file was added"
          done
        env:
          ADDED_FILES: ${{ steps.changed-files.outputs.added_files }}
          MODIFIED_FILES: ${{ steps.changed-files.outputs.modified_files }}

      - name: Run Check
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');

            const escapeHtml = (unsafe) => unsafe.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#039;');
            const errors = [];
            const addError = (error) =>
            {
                errors.push(`:x: ${error}`);
                console.log('Found issue: ' + error);
            };

            const warnings = [];
            const addWarning = ( warning ) =>
            {
                warnings.push(`:warning: ${warning}`);
                console.log( 'Found issue: ' + warning );
            }

            /*
                Regex Searches
            */

            const filesModified               = '${{ steps.changed-files.outputs.modified_files }}';
            const filesData                   = fs.readFileSync( filesModified, 'utf8' );
            const bContainsStyle              = /([A-Za-z]+\.style\.[A-Za-z]+)/gi.test( filesData );
            const bContainsGeneric            = /(?:^|(?<= ))(MyPlugin|MyPluginSettings|SampleSettings|SampleSettingTab|SampleModal|Sample Plugin|my-plugin)(?:(?= )|$)/gim.test( filesData );
            const bFuncFetch                  = /(fetch)\((.*)\)(\[([^\]]*)\])?/gim.test( filesData );
            const bVar                        = /^(?:var|)\s(\w+)\s*=\s*/gm.test( filesData );
            const bLookBehind                 = /(\(([?:]<[^()]+|)*\))/gmi.test( filesData );
            const bMarkdownHtmlNode           = /new\s+NodeHtmlMarkdown/gmi.test( filesData );
            const bAsTFile                    = /as\s+TFile/g.test( filesData );
            const bAsTFolder                  = /as\s+TFolder/g.test( filesData );
            const bAsAny                      = /\((.*? as Any\s*)\)/gi.test( filesData );
            const bInnerHTML                  = /^\s?[a-zA-Z0-9_]+\.innerHTML*\s?.*$/gm.test( filesData );
            const bOuterHTML                  = /^\s?[a-zA-Z0-9_]+\.outerHTML*\s?.*$/gm.test( filesData );

            const check_depGetUnpinnedLeaf    = "app.workspace.getUnpinnedLeaf"

            let error_Generic = "\n" + 
             "- `MyPlugin`\n" + 
             "- `MyPluginSettings`\n" + 
             "- `SampleSettings`\n" +
             "- `SampleSettingTab`\n" +
             "- `SampleModal`"

            await ( async ( ) =>
            {

                /*
                    (Deprecated) app.workspace.getUnpinnedLeaf
                */

                if ( filesData.toLowerCase( ).includes( check_depGetUnpinnedLeaf.toLowerCase( ) ) )
                {
                    addError( "This function is deprecated, use `this.app.workspace.getLeaf( false )` instead" );
                }

                /*
                    Using inline style
                */

                if ( bContainsStyle == true )
                {
                    addError( "Avoid assigning `inline styles` via JavaScript or in HTML. Move these styles to CSS so that they are adaptable by themes and other plugins." );
                }

                /*
                    Using fetch
                */

                if ( bFuncFetch == true )
                {
                    addError( "Do not handle http data with `fetch( )`. Use the Obsidian API -> `requestUrl` method instead, which will make sure that network requests work on every platform." );
                }

                /*
                    Using var
                */

                if ( bVar == true )
                {
                    addError( "Change all instances of `var` to **const** or **let**. var has function-level scope, and leads to bugs." );
                }

                /*
                    Using lookbehind
                */

                if ( bLookBehind == true )
                {
                    addError( "Lookbehinds are not supported in iOS < 16.4" );
                }

                /*
                    Using HTML Node
                */

                if ( bMarkdownHtmlNode == true )
                {
                    addError( "Do not use `NodeHtmlMarkdown`. Use Obsidian API -> `htmlToMarkdown` instead." );
                }

                /*
                    As TFile
                */

                if ( bAsTFile == true )
                {
                    addError( "Do not cast `as TFile`, use `instanceof` instead to check if the item is actually a file / folder" );
                }

                /*
                    As TFolder
                */

                if ( bAsTFolder == true )
                {
                    addError( "Do not cast `as TFolder`, use `instanceof` instead to check if the item is actually a file / folder" );
                }

                /*
                    Casting to Any
                */

                if ( bAsAny == true )
                {
                    addError( "Do not cast to `Any`" );
                }

                /*
                    innerHTML
                */

                if ( bInnerHTML == true )
                {
                    addError( `Using \`innerHTML\` is a security risk. Use the DOM API or the Obsidian helper functions: https://docs.obsidian.md/Plugins/User+interface/HTML+elements` );
                }

                /*
                    outerHTML
                */

                if ( bOuterHTML == true )
                {
                    addError( `Using \`outerHTML\` is a security risk. Use the DOM API or the Obsidian helper functions: https://docs.obsidian.md/Plugins/User+interface/HTML+elements` );
                }

                /*
                    Generic Calls
                */

                if ( bContainsGeneric == true )
                {
                    addError( "Rename sample classes to something that makes sense. You are not allowed to have names such as: " + error_Generic );
                }

            })();

            if ( errors.length > 0 || warnings.length > 0 )
            {

                /*
                    Greeting
                */

                let message = [`#### Report!\n`]
                message.push( `**I found the following issues in your pull request:**\n` );

                /*
                    Errors
                */

                if ( errors.length > 0 )
                {
                    message.push( `**Errors:**\n` );
                    message = message.concat( errors );
                    message.push( `\n---\n` );
                }

                /*
                    Warnings
                */

                if ( warnings.length > 0 )
                {
                    message.push( `**Warnings:**\n` );
                    message = message.concat( warnings );
                    message.push( `\n---\n` );
                }

                message.push( `<sup>This check was done automatically. Do <b>NOT</b> open a new PR for re-validation. Instead, to trigger this check again, make a change to your PR and wait a few minutes, or close and re-open it.</sup>` );

                await github.rest.issues.createComment(
                {
                    issue_number:   context.issue.number,
                    owner:          context.repo.owner,
                    repo:           context.repo.repo,
                    body:           message.join('\n'),
                });
            }
    
            const labels = [];

            if ( errors.length > 0 )
            {
                labels.push( "Validation failed" );
                core.setFailed( "Failed to validate pull request" );
            }

            if ( errors.length === 0 )
            {
                await github.rest.pulls.update(
                {
                    owner:        context.repo.owner,
                    repo:         context.repo.repo,
                    pull_number:  context.issue.number,
                    title:        `Review: ${context.payload.pull_request.title}`
                });

                if( !context.payload.pull_request.labels.filter( label => label.name === 'Changes requested' ).length > 0 )
                {
                    labels.push("Ready for review");
                }
            }

            if ( context.payload.pull_request.labels.filter( label => label.name === 'Changes requested' ).length > 0 )
            {
                labels.push('Changes requested');
            }

            if ( context.payload.pull_request.labels.filter( label => label.name === 'Additional review required' ).length > 0 )
            {
                labels.push( 'Additional review required' );
            }

            if (context.payload.pull_request.labels.filter(label => label.name === 'Minor changes requested').length > 0)
            {
                labels.push( 'Minor changes requested' );
            }

            if (context.payload.pull_request.labels.filter(label => label.name === 'requires author rebase').length > 0)
            {
                labels.push( 'requires author rebase' );
            }

            if (context.payload.pull_request.labels.filter(label => label.name === 'Installation not recommended').length > 0)
            {
                labels.push( 'Installation not recommended' );
            }

            if (context.payload.pull_request.labels.filter( label => label.name === 'Changes made' ).length > 0 )
            {
                labels.push( 'Changes made' );
            }
            
            if ( context.payload.pull_request.labels.filter( label => label.name === 'Skipped code scan' ).length > 0 )
            {
                labels.push( 'Skipped code scan' );
            }

            labels.push( 'Pull Request' );

            await github.rest.issues.setLabels(
            {
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                labels,
            });
    permissions:
      contents: read
      issues: write
      pull-requests: write