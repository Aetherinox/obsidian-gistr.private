# ---------------------------------------------------------------------------------------
#   @parent     : github workflow
#   @desc       : manually activated workflow to create issue labels
#   @author     : Aetherinox
#   @url        : https://github.com/Aetherinox
# ---------------------------------------------------------------------------------------

name: "üé´ Labels ‚Ä∫ Check"
run-name: "üé´ Labels ‚Ä∫ Check"

# ---------------------------------------------------------------------------------------
#   triggers
# ---------------------------------------------------------------------------------------

on:
  workflow_dispatch:

# ---------------------------------------------------------------------------------------
#   environment variables
# ---------------------------------------------------------------------------------------

env:
  PREFIX_BUG:           "Bug"
  PREFIX_FEATURE:       "Feature"
  PREFIX_ROADMAP:       "Roadmap"
  PREFIX_DEPENDENCY:    "Dependency"
  PREFIX_PR:            "PR"
  PREFIX_DOCS:          "Docs"
  PREFIX_GIT:           "Git Action"
  PREFIX_URGENT:        "Urgent"

  LABEL_BUG:            "Type ‚á¥ Bug"
  LABEL_FEATURE:        "Type ‚á¥ Feature"
  LABEL_ROADMAP:        "Type ‚á¥ Roadmap"
  LABEL_DEPENDENCY:     "Type ‚á¥ Dependency"
  LABEL_PR:             "Type ‚á¥ PR"
  LABEL_DOCS:           "Type ‚á¥ Docs"
  LABEL_GIT:            "Type ‚á¥ Git Action"
  LABEL_URGENT:         "‚ö† Urgent"

  ASSIGN_USER:          Aetherinox
  BOT_NAME_1:           AdminServ
  BOT_NAME_2:           AdminServX
  BOT_NAME_DEPENDABOT:  dependabot[bot]
  LABELS_JSON: |
    [
      { "name": "Type ‚á¥ Bug",             "color": "9a2c2c", "description": "Something isn't working" },
      { "name": "Type ‚á¥ Feature",         "color": "F62735", "description": "Feature request" },
      { "name": "Type ‚á¥ Roadmap",         "color": "8F1784", "description": "Feature or bug currently planned for implementation" },
      { "name": "Type ‚á¥ Dependency",      "color": "243759", "description": "Item is associated to dependency" },
      { "name": "Type ‚á¥ PR",              "color": "8F1784", "description": "Item is marked as a Pull Request" },
      { "name": "Type ‚á¥ Docs",            "color": "0e588d", "description": "Improvements or modifications to docs" },
      { "name": "Type ‚á¥ Git Action",      "color": "030406", "description": "Pull requests that update GitHub Actions code" },
      { "name": "Status ‚ÜØ Review",        "color": "6E465A", "description": "This item is currently pending review" },
      { "name": "Status ‚ÜØ Released",      "color": "1b6626", "description": "Issues or PR has been implemented and is now live" },
      { "name": "Status ‚ÜØ Accepted",      "color": "2e7539", "description": "This pull request has been accepted" },
      { "name": "Status ‚ÜØ Review",        "color": "9e1451", "description": "Item is currently pending review" },
      { "name": "Status ‚ÜØ Denied",        "color": "ba4058", "description": "Pull request has been denied" },
      { "name": "Status ‚ÜØ Need Info",     "color": "2E3C4C", "description": "Not enough information to resolve" },
      { "name": "Status ‚ÜØ No Action",     "color": "030406", "description": "This request was closed without any action being taken" },
      { "name": "Status ‚ÜØ Pending",       "color": "D5155E", "description": "Pending pull request" },
      { "name": "Status ‚ÜØ Reopened",      "color": "B78D03", "description": "A previously closed PR which has been re-opened" },
      { "name": "‚ö† Urgent",              "color": "a8740e", "description": "Requires urgent attention" },
      { "name": "AC/Failed",              "color": "d73a4a", "description": "Autocheck failed to run through a complete cycle, requires investigation" },
      { "name": "AC/Changes Required",    "color": "36552B", "description": "The PR requires changes to be made to the package before it will be accepted" },
      { "name": "AC/Passed",              "color": "ccb11d", "description": "PR is ready to be reviewed by primary developer" },
      { "name": "AC/Review Required",     "color": "8F1784", "description": "PR needs to be reviewed by another person, after the currently requested changes have been made" },
      { "name": "AC/Needs Rebase",        "color": "8F1784", "description": "Due to the permissions on the requesting repo, this pull request must be rebased by the author" },
      { "name": "AC/Security Warning",    "color": "8F1784", "description": "Pull request contents does not conform to developer policies, or includes potentially dangerous code" },
      { "name": "AC/Changes Made",        "color": "8F1784", "description": "The requested changes have been made and is pending a re-scan" },
      { "name": "AC/Skipped Scan",        "color": "8F1784", "description": "Code scanning skipped because PR author believes result is wrong" }
    ]

jobs:

  # ---------------------------------------------------------------------------------------
  #   Verify Existing Labels
  #   This job will ensure you have labels already created in your repo.
  #
  #   All labels come from the JSON table LABELS_JSON.
  # ---------------------------------------------------------------------------------------

  issues-labels-create:
    name: üé´ Labels ‚Ä∫ Preconfigure
    runs-on: ubuntu-latest
    steps:

      - name: "‚úÖ Start"
        run: | 
              echo "Assigning labels and assignees"

      # ---------------------------------------------------------------------------------------
      #   checkout
      # ---------------------------------------------------------------------------------------

      - name: "‚òëÔ∏è Checkout"
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # ---------------------------------------------------------------------------------------
      #   Check if repo has labels currently added to issues
      # ---------------------------------------------------------------------------------------
        
      - name: üè∑Ô∏è Verify Existing Labels
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ADMINSERV_TOKEN_CL }}
          script: |
            const labels = JSON.parse( process.env.LABELS_JSON );
            for ( const label of labels )
            {
                try
                {
                    await github.rest.issues.createLabel(
                    {
                        owner:        context.repo.owner,
                        repo:         context.repo.repo,
                        name:         label.name,
                        description:  label.description || '',
                        color:        label.color
                    });
                }
                catch ( err )
                {
                    if ( err.status === 422 )
                    {
                        console.log( `Label '${label.name}' already exists. Skipping.` );
                    }
                    else
                    {
                        console.error( `Error creating label '${label.name}': ${err}` );
                    }
                }
            }
  
  issues-labels-check:
    name: üé´ Labels ‚Ä∫ Check
    runs-on: ubuntu-latest
    needs: issues-labels-create
    steps:

      # ---------------------------------------------------------------------------------------
      #   checkout
      # ---------------------------------------------------------------------------------------

      - name: "‚òëÔ∏è Prepare"
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # ---------------------------------------------------------------------------------------
      #   Check if repo has labels currently added to issues
      # ---------------------------------------------------------------------------------------
        
      - name: üè∑Ô∏è Check ‚Ä∫ Bugs
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ADMINSERV_TOKEN_CL }}
          script: |
        
            /*
                Change last number ( 36 = hours )
            */

            const expireAfterMs   = 1000 * 60 * 60 * 36;
            const curtime         = new Date( ).getTime( );
            const issues          = await github.rest.issues.listForRepo( { owner: context.repo.owner, repo: context.repo.repo, state: 'open' } );
  
            console.log( `  üì¶‚îÄ‚îÄ  Found ${issues.data.length} open issues` );

            for ( const issue of issues.data )
            {
                const time_LastUpdate     = new Date( issue.updated_at ).getTime( );
                //if ( curtime < time_LastUpdate + expireAfterMs ) continue;

                /*
                    Anything past this point is stale / to be closed
                */

                const timeline          = await github.rest.issues.listEventsForTimeline( { owner: context.repo.owner, repo: context.repo.repo, issue_number: issue.number } );
                // const labelEvent     = timeline.data.find( event => event.event === 'labeled' && event.label.name === 'status-stale' );

                /*
                    Get Issue Data
                */

                const add_labels        = issue.labels.map( label => label.name );

                let iss_title           = `${ issue.title }`;
                const iss_title_lc      = iss_title.toLowerCase( );

                let iss_body            = `${ issue.body }`;
                const iss_body_lc       = iss_body.toLowerCase( );

                console.log( `      ‚îî‚îÄ‚îÄ üìÅ ` + iss_title );
                console.log( `         ‚îî‚îÄ‚îÄ üìÑ Issue #${ issue.number } last updated on ${ time_LastUpdate }` );
                console.log( `         ‚îî‚îÄ‚îÄ üìÑ ${add_labels}` );
                console.log( `\n` )

                /*
                    Keywords
                */

                const KwordsBugs          = [ "bug", "broke", "issue", "fail" ];
                const KwordFeature        = [ "feature", "request", "add support" ];
                const KwordUrgn           = [ "urgent", "urgency", "emergency", "important", "critical" ];
                const KwordRoad           = [ "roadmap", "road map", "planned" ];

                /*
                    Label > Bugs
                */

                const iss_tag             = `${{ env.PREFIX_BUG }}`;
                const inss_label          = `${{ env.LABEL_BUG }}`;
                const bKwordBugsIncT      = KwordsBugs.some( s => s.includes( iss_title_lc ) || iss_title_lc.includes( s ) );
                const bKwordBugsIncB      = KwordsBugs.some( s => s.includes( iss_body_lc ) || iss_body_lc.includes( s ) );

                /*
                    - Check if issue title matches the issue label "Bug:"
                    - Check if title contains word in containsList 
                */

                if ( iss_title_lc.startsWith( iss_tag.toLowerCase( ) ) || bKwordBugsIncT || bKwordBugsIncB )
                {

                    add_labels.push( `${ inss_label }` );

                    // Rename title to contain Bug:
                    if ( !iss_title_lc.startsWith( iss_tag.toLowerCase( ) ) )
                    {
                        const title           = issue.title;
                        let title_new         = title.replace( /^\s?bug\s*(.*?)\b/gi, '' );
                        title_new         		= title.replace( /^\s?fail\s*(.*?)\b/gi, '' );
                        title_new         		= title.replace( /^\s?issue\s*(.*?)\b/gi, '' );
                        iss_title             = `${ iss_tag }: ${ title_new }`;
                    }

                    await github.rest.issues.update(
                    {
                        owner: context.repo.owner, repo: context.repo.repo, issue_number: issue.number,
                        title: `${ iss_title }`, labels: add_labels
                    } );
                }

                /*
                    Label > Features
                */

                const iss_tag             = `${{ env.PREFIX_FEATURE }}`;
                const inss_label          = `${{ env.LABEL_FEATURE }}`;
                const bKwordFeatIncT      = KwordFeature.some( s => s.includes( iss_title_lc ) || iss_title_lc.includes( s ) );
                const bKwordFeatIncB      = KwordFeature.some( s => s.includes( iss_body_lc ) || iss_body_lc.includes( s ) );

                /*
                    - Check if issue title matches the issue label "Feature:"
                    - Check if title contains word in containsList 
                */

                if ( iss_title_lc.startsWith( iss_tag.toLowerCase( ) ) || bKwordFeatIncT || bKwordFeatIncB )
                {

                    add_labels.push( `${ inss_label }` );

                    // Rename title to contain Feature:
                    if ( !iss_title_lc.startsWith( iss_tag.toLowerCase( ) ) )
                    {
                        const title           = issue.title;
                        let title_new         = title.replace( /^\s?feature\s*(.*?)\b/gi, '' );
                        title_new             = title.replace( /^\s?request\s*(.*?)\b/gi, '' );
                        title_new             = title.replace( /^\s?add(.*?)\s?feature\s*(.*?)\b/gi, '' );
                        title_new             = title.replace( /^\s?add(.*?)\s?support\s*(.*?)\b/gi, '' );
                        iss_title             = `${ iss_tag }: ${ title_new }`;
                    }

                    await github.rest.issues.update(
                    {
                        owner: context.repo.owner, repo: context.repo.repo, issue_number: issue.number,
                        title: `${ iss_title }`, labels: add_labels
                    } );
                }

                /*
                    Label > Urgent
                */

                const iss_tag             = `${{ env.PREFIX_URGENT }}`;
                const inss_label          = `${{ env.LABEL_URGENT }}`;
                const bKwordUrgnIncT      = KwordUrgn.some( s => s.includes( iss_title_lc ) || iss_title_lc.includes( s ) );
                const bKwordUrgnIncB      = KwordUrgn.some( s => s.includes( iss_body_lc ) || iss_body_lc.includes( s ) );

                /*
                    - Check if issue title matches the issue label "Urgent:"
                    - Check if title contains word in containsList 
                */

                if ( iss_title_lc.startsWith( iss_tag.toLowerCase( ) ) || bKwordUrgnIncT || bKwordUrgnIncB )
                {

                    add_labels.push( `${ inss_label }` );

                    // Rename title to contain Urgent:
                    if ( !iss_title_lc.startsWith( iss_tag.toLowerCase( ) ) )
                    {
                        const title           = issue.title;
                        let title_new         = title.replace( /^\s?emergency\s*(.*?)\b/gi, '' );
                        title_new             = title.replace( /^\s?urgent\s*(.*?)\b/gi, '' );
                        title_new             = title.replace( /^\s?urgency\s*(.*?)\b/gi, '' );
                        title_new             = title.replace( /^\s?important\s*(.*?)\b/gi, '' );
                        title_new             = title.replace( /^\s?critical\s*(.*?)\b/gi, '' );
                        iss_title             = `${ iss_tag }: ${ title_new }`;
                    }

                    await github.rest.issues.update(
                    {
                        owner: context.repo.owner, repo: context.repo.repo, issue_number: issue.number,
                        title: `${ iss_title }`, labels: add_labels
                    } );
                }

                /*
                    Label > Roadmap
                */

                const iss_tag             = `${{ env.PREFIX_ROADMAP }}`;
                const inss_label          = `${{ env.LABEL_ROADMAP }}`;
                const bKwordRoadIncT      = KwordRoad.some( s => s.includes( iss_title_lc ) || iss_title_lc.includes( s ) );
                const bKwordRoadIncB      = KwordRoad.some( s => s.includes( iss_body_lc ) || iss_body_lc.includes( s ) );

                /*
                    - Check if issue title matches the issue label "Roadmap:"
                    - Check if title contains word in containsList 
                */

                if ( iss_title_lc.startsWith( iss_tag.toLowerCase( ) ) || bKwordRoadIncT || bKwordRoadIncB )
                {

                    add_labels.push( `${ inss_label }` );

                    // Rename title to contain Roadmap:
                    if ( !iss_title_lc.startsWith( iss_tag.toLowerCase( ) ) )
                    {
                        const title           = issue.title;
                        let title_new         = title.replace( /^\s?emergency\s*(.*?)\b/gi, '' );
                        title_new             = title.replace( /^\s?urgent\s*(.*?)\b/gi, '' );
                        title_new             = title.replace( /^\s?urgency\s*(.*?)\b/gi, '' );
                        title_new             = title.replace( /^\s?important\s*(.*?)\b/gi, '' );
                        title_new             = title.replace( /^\s?critical\s*(.*?)\b/gi, '' );
                        iss_title             = `${ iss_tag }: ${ title_new }`;
                    }

                    await github.rest.issues.update(
                    {
                        owner: context.repo.owner, repo: context.repo.repo, issue_number: issue.number,
                        title: `${ iss_title }`, labels: add_labels
                    } );
                }

                /*
                await github.rest.issues.update(
                {
                    owner: context.repo.owner, repo: context.repo.repo, issue_number: issue.number,
                    state: 'closed', state_reason: 'not planned'
                } );
                */

            }


